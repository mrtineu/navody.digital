<%= form_with model: @upvs_submission, url: upvs_submission_submit_path(@upvs_submission), method: 'POST', id: :new_message, builder: AppFormBuilder do |f| %>
  <h1 class="govuk-heading-l"><%= @upvs_submission.title %></h1>
  <p class="govuk-body-l">Pripravené na odoslanie.</p>

  <%= render 'components/error_summary', form: @upvs_submission %>
  <%= render partial: 'sender' %>

  <div class="govuk-form-group">
    <%= f.label :recipient_name, 'Príjimateľ správy', class: 'govuk-label' %>
    <%= f.text_field :recipient_name, disabled: true %>
    <div id="recipient-name-container"></div>
  </div>

  <div id="iframe-wrapper">
    <iframe id="iframe"  srcdoc="<%= raw @upvs_submission.form_visualisation %>"
      onload="(
        function() {
          $('#iframe-wrapper').height( $('#iframe').contents().outerHeight() + 2 );
        }
        (this)
      )">
    </iframe>
  </div>

  <%= render 'upvs/submissions/blob_sign_button', blob: @upvs_submission.form %>

  <% if @upvs_submission.attachments.attached? %>
    <table class="govuk-table">
      <thead class="govuk-table__head">
      <tr class="govuk-table__row">
        <td scope="col" class="govuk-table__header">Požadovaný súbor</td>
        <td scope="col" class="govuk-table__header">Názov súboru</td>
        <td scope="col" class="govuk-table__header">Vyžaduje podpis?</td>
        <td scope="col" class="govuk-table__header"></td>
      </tr>
      </thead>
      <tbody class="govuk-table__body">
        <% @upvs_submission.attachments.each do |blob| %>
          <tr class="govuk-table__row">
            <td class="govuk-table__cell">
              <%= blob.metadata[:original_template_name] %><br>
            </td>
            <td class="govuk-table__cell"><%= blob.filename %></td>
            <td class="govuk-table__cell"><%= lb blob.metadata[:signed_required] %></td>
            <td class="govuk-table__cell">
              <%= render 'upvs/submissions/blob_sign_button', blob: blob %>
            </td>
            </tr>
          <% end %>
        </tbody>
      </table>
  <% end %>

  <%= render partial: 'actions' %>
<% end %>

<script>
  const authenticityToken = '<%= form_authenticity_token %>';

  async function sign(messageObjectPath, blob_id, batchId = null) {
    return new Promise((resolve, reject) => {
      fetch(messageObjectPath)
        .then(function (response) {
          return response.json();
        }).then(async function (messageObjectData) {
        let payloadMimeType = `${messageObjectData.mime_type};base64`;
        let signatureLevel = "XAdES_BASELINE_B";
        let signatureContainer = "ASiC_E";

        let signedFileName = await setSignedFileName(messageObjectData);
        let signedFileMimeType = "application/vnd.etsi.asic-e+zip";

        switch(messageObjectData.mime_type) {
          case "application/pdf":
            signatureLevel = "PAdES_BASELINE_B";
            signatureContainer = null;

            signedFileName = messageObjectData.file_name;
            signedFileMimeType = messageObjectData.mime_type;
            break;
          // TODO check what in this case
          // case 'application/xml':
          //   break;
          case 'application/x-eform-xml':
            payloadMimeType = "application/xml;base64"
            break;
          case 'application/msword':
          case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
            payloadMimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64"
            break;
          case 'image/jpeg':
          case 'image/tiff':
          case 'image/png':
            signatureLevel = "CAdES_BASELINE_B";
            break;
        }

        fetch("http://localhost:37200/sign", {
          method: "POST",
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            batchId: batchId,
            document: {
              filename: messageObjectData.file_name,
              content: messageObjectData.content
            },
            parameters: {
              level: signatureLevel,
              container: signatureContainer,
              identifier: messageObjectData.identifier,
              schema: messageObjectData.schema,
              containerXmlns: messageObjectData.container_xmlns,
              transformation: messageObjectData.transformation
            },
            payloadMimeType: payloadMimeType
          })
        }).then(function (response) {
          if (response.ok) {
            return response.json();
          } else {
            throw new Error
          }
        }).then(function (signedData) {
          updateObject(messageObjectPath, signedFileName, signedFileMimeType, signedData.content, blob_id);
        }).then(function () {
          resolve();
        }).catch(function (err) {
          if (err.message === "Failed to fetch") {
            alert("Spustite aplikáciu autogram.")
          } else {
            alert("Podpisovanie neprebehlo úspešne.");
          }
        });
      })
    });
  }

  // TODO doriesit co namiesto turba
  async function updateObject(messageObjectPath, signedFileName, signedFileMimeType, signedContent, blob_id) {
    return new Promise((resolve, reject) => {
      blobWrapperId = `signature-for-blob-${blob_id}`
      blobWrapper = document.getElementById(blobWrapperId)

      // request.js lib is used, responseKind: "turbo-stream" option is very important (be careful if case of changes)
      fetch(messageObjectPath, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          authenticity_token: authenticityToken,
          name: signedFileName,
          mimetype: signedFileMimeType,
          is_signed: true,
          content: signedContent,
          render_partial: blobWrapper.dataset.partial
        })
      }).then(function (response) {
        if (response.ok) {
          return response.json();
        } else {
          throw new Error;
        }
      }).then(function (response) {
        if (response.success) {
          blobWrapper.innerHTML = response.html;
        } else {
          alert(response.error);
        }
      }).catch(function () {
        alert("Podpisovanie neprebehlo úspešne.")
      });
    });
  }

  async function setSignedFileName(messageObjectData) {
    return messageObjectData.file_name.substring(0, messageObjectData.file_name.lastIndexOf('.')).concat(".asice") || messageObjectData.file_name;
  }

  function signMultipleFiles() {
    const messageObjectsToBeSigned = JSON.parse(this.data.get("filesToBeSigned"));

    fetch("http://localhost:37200/batch", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
        "totalNumberOfDocuments": messageObjectsToBeSigned.length
      })
    }).then(function (response) {
      return response.json();
    }).then(function (data) {
      return data.batchId;
    }).then(async function (batchId) {
      for(const messageObject of messageObjectsToBeSigned) {
        await sign(messageObject.path, batchId);
      }
    }).catch(function (err) {
      if (err.message === "Failed to fetch") {
        alert("Spustite aplikáciu autogram.")
      }
      else {
        alert("Podpisovanie neprebehlo úspešne.")
      }
    });
  }
</script>
